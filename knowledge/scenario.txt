This is proposed work flow:

There are several re-spawn points where bot cars appeared.
All these points located on some map board borders.
First 3 seconds our main car is waiting, this time bot cars appeared
and moved to their destination. This delay is required to create real traffic
before main car starts.

Main car knows own destination point, calculates the shortest path
and move according to it. For now no changes in route according to real road traffic.

There is predefined destination point for all cars in re-spawn point.
It means all of them move on the same route.


Cars:
There are 2 types of cars: car and truck.
Car has less length, width, but more maximum velocity and time headway.
Trucks have more length, width, but less maximum velocity and time headway.


Goal:
The very first prototype must contain two cars: main and companion
and they must interact in appropriate way. It means move according to
programmed model.


Workflow:

1. Load info for map.
It stored in .json file and contains next data:
Roads: start point, end point, direction: from bottom to up, from up to bottom,
from left to right, from right to left. This information used for rendering.

Each vehicle just move forward during calculation with no knowledge about road
direction.

Each road has 2 forward and backward lanes:
Backward  Forward
 |↓||↓|   |↑||↑|
 |↓||↓|   |↑||↑|
 |↓||↓|   |↑||↑|

We use right-hand traffic, we are not dump British ones.

Width of each lane is fixed, lane's length equal to road's length.
Map creates special object Hurdle at any roads connection point to make
vehicles decrease velocity.


After that spawn points are listed. They assigned to some lane.
Each spawn point has appropriate destination point.

Main car origin and destination points. The main car is the one which
route we model and calculate.
Also road id and lane id provided to know beforehand where to add the main car.


Next data are traffic lights: location - it is junction of 4 roads.
Traffic light used also for denoting intersections: each vehicle slows down
before any hurdle.

Traffic light has next properties: time and light.
Time is a spent time after last light change.
Each light has own period:
Red light 20s
Yellow light 3s
Green light 30s

Map is a square, for example, 1000x1000.
Calculations are free from representation and renderer only use info after
calculations on each step.

2. Create initial traffic

First 3 seconds used for creating vehicles on the map before car is of the
interest to make "crowd".
This time spawn points generate vehicles: trucks and cars with some interval.
Proposed values: 20% probability to create truck and 80% for car.
Initial velocity is in range [15-30] km/h for trucks and [30-45] km/h.

Spawn point logic:
The point has predefined route: starting lane where a vehicle appeared and
destination point where the vehicle is moving. Path calculated by Dijkstra's
algorithm and never changed. Or can be set manually.

Start simulation.


3. Simulation

3.1 Vehicle properties
Each car has next properties:
- position;
- velocity;
- acceleration;
- type: Truck or Car.
- global parameters
- politeness factor;
- state: moving, changing lane, idle.
- - Moving state: vehicle on move (no matter, increasing or decreasing velocity)
	only du > 0, dv = 0. du - moving along lane, dv - moving across lane
- - Changing lane: du > 0, dv > 0
- - idle: the vehicle doesn't move, du = dv = 0
- index of leading the vehicle (vehicle before current one)

3.2 Lane properties
Lane has array of vehicles, sorted in the same order they are on the lane
orientation: forward or backward (used in rendering)

3.3 Road properties
Each road has overall width and length.
Forward lanes: array[2]
Backward lanes: array[2]

3.4 Junction

?. Add Main Car to the road
Calculate the shortest path for the main car. Add it to the lane.







///////////////////////////////////////////////////////

Workflow from routing.js
1. Create IDM and MOBIL objects for different vehicles.
lines 253-265

2. Create 2 roads: main and deviation.
Initialize properties of roads.
lines 272-288

3. Add virtual vehicle at the end of on-ramp (it served as an obstacle) to the
beginning of deviation road.
lines 295-300

4. Add virtual roadwork vehicles(also served as obstacles).
After that sort vehicles according to position on lane by u coordinate
in descending order.(the less index the closer vehicle to the end of lane).
updateEnvironment() sets leader and follower vehicle for each vehicle on the
present, left and right lanes.
lines 308-322

5. Set route for each vehicle on main road.
fracOff is a fraction of offramps and can be changed by UI.

6. Next part is the very important updateU() function.
There are 2 roads: main - road with 2 straight parts and one arc and
deviation - road with on-ramp and offramp and laid below main road.
lDev is a length of deviation
lrampDev is a length of merge and diverge points on main road
diverge point is a on-ramp - ability to switch to another road, namely deviation
merge point is a location where vehicles leave deviation and again move on
main road.
-------------------------------------------------------
7. updateTruckFrac() looks for current percentage of trucks among all vehicles
and decide whether add more trucks to reach desired fraction or car.

8. updateModelsOfAllVehicles()
- select model object for each type of vehicle
- find index of the nearest offramp by getNextOffIndex()
- look if the vehicle has route with this offramp
- decide whether turn left or right
- update Lane Change (LC) model

9. setLCMandatory()
if a vehicle in the range [umin; umax], set its LC model as mandatory.
It means make the vehicle change lane.

10. call setCFModelsInRange() for deviation
if a vehicle in the range [umin; umax], set it longModel (may be longitudinal
model) to CF model. CF is a flow-conserving, used to set behaviour model in
bottlenecks.

11. updateLastLCtimes()
add dt to fields dt_lastLC - time after the last lane change
the same for dt_lastPassiveLC

12. calcAccelerations() - calculate accelerations of each vehicle

13. changeLanes()
- iterate over all vehicles on lane and check whether it moves to the right lane
- the same, but for the left lane

14. updateSpeedPositions()
- update acceleration for each vehicle
- update speed for each vehicle
- update info about leaders/followers for all vehicles

15. updateBCdown()
Check if vehicle on downstream, if yes, remove the first vehicle

16. updateBCup()
Check if vehicle on upstream
inVehBuffer used, it is a number of waiting vehicles, if >= 1 -> then used.
If more than 1 waiting vehicle, create new one and try to insert to road.
At first vehicle suggested for insert to the right lane, if failed, try to
insert to any lane. Decrease the number of waiting vehicles.
